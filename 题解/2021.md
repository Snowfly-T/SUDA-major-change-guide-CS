---
description: By 高歌
---

# 2021年转专业考试题解

*目前来说，只有题，没有解*

1. 一个正整数，如果它能被9整除，或者它的十进制表示法中某一位上的数字为9， 则称其为与9相关的数。请计算所有小于等于$$n(n < 100)$$的与9无关的正整数的平方和。

   | **相关说明** |                     |
   | ------------ | ------------------- |
   | 输入条件     | $$n$$是正整数       |
   | 输出要求     | 以整数形式返回结果  |
   | 其它要求     | 将代码写入函数func1 |

   ---

   测试用例：

   | **输入** | **输出** |
   | -------- | -------- |
   | 2        | 5        |
   | 9        | 204      |
   | 18       | 1704     |

   ---

   <b>解：</b>作为第一题还是很简单的一道题目。数据量很小，不需要什么优化，暴力做就行。一般这种题目如果已经明确指出数据量很小就不要考虑优化了，也不会多得分，纯属浪费时间。

   ```python
   def func1(n):
       result = 0
       for i in range(n):
           if not (i % 9 == 0 or '9' in str(i)):
               result += i * i
       return result
   ```

   要是乐意也可以一行流，实际上一行流还会稍微快一点（10%左右，其实也比较有限，意义不大）

   ```python
   def func1(n):
       return sum(i * i for i in range(n) if not (i % 9 == 0 or '9' in str(i)))
   ```

   ---

2. 现有一个列表lst包含了$$n$$个$$[-100,100]$$之间的整数，请编写程序返回出现次数最多的整数，当有多个出现次数相同的整数时，请返回最小的那一个整数。

   | **相关说明** |                                             |
   | ------------ | ------------------------------------------- |
   | 输入条件     | lst中的整数一定合法                         |
   | 输出要求     | 如果lst为空返回None，否则返回满足条件的整数 |
   | 其它要求     | 将代码写入函数func2                         |

   ---

   测试用例：

   | **输入**      | **输出** |
   | ------------- | -------- |
   | [-100,1,100]  | -100     |
   | [3,5,7,3,8,9] | 3        |
   | [3,5,5,3,5,9] | 5        |

   ---

   <b>解：</b>经典Python题，没什么好说的。这里代码中最后max的key也可以写成`key=lambda x: count[x]`，可能更好理解点。如果看不懂最后的max是怎么回事，先用sorted按值排个序取第一个也可以，方法很多，这里只给出一个参考。

   ```python
   def func2(lst):
       count = {}
       for num in lst:
           count[num] = count.get(num, 0) + 1
       return max(count, key=count.get)
   ```

   Python中实际上还提供了Counter类用于类似的场景。不过就这道题来说，没什么必要。而且如果用Counter很轻松地解决了问题，难说会不会扣分。

   ```python
   def func2(lst):
       from collections import Counter
       return Counter(lst).most_common(1)[0][0]
   ```

   ---

3. 给定一个元素是$$[0,9]$$之间的整数且没有重复数字的列表lst，返回其所有可能的全排列。全排列列表中的每个元素也是列表，全排列列表按照数值从小到大排序。

   | **相关说明** |                                                |
   | ------------ | ---------------------------------------------- |
   | 输入条件     | lst是不包含重复元素的整数列表，元素都在0-9之间 |
   | 输出要求     | lst元素的全排列列表，列表中的元素从小到大排序  |
   | 其它要求     | 将代码写入函数func3                            |

   ---

   测试用例：

   | **输入** | **输出**                                                     |
   | -------- | ------------------------------------------------------------ |
   | [1,2,3]  | [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] |
   | [1]      | [[1]]                                                        |
   | []       | [[]]                                                         |

   ---

   <b>解：</b>2021年的这道全排列题确实是有些出人意料，主要是这道题出现在这么靠前的位置有些劝退，实际上后面大多数题都比这道题简单。虽说如此，全排列这道题也是一道非常经典的回溯基础题了，LeetCode第46题和这题完全一样，区别只是这道题需要多个排序而已。如果刷题比较勤快，这道题是应该没有什么问题的。

   下面演示一个最简单直接的暴力递归做法。虽然暴力，但时间开销其实和标准回溯差不多：

   ```python
   def func3(lst):
       def go(lst):
           if len(lst) == 0:
               return [[]]
           elif len(lst) == 1:
               return [lst]
           else:
               head, tail = lst[0], lst[1:]
               result = []
               for l in go(tail): # 对每个子列表分别插值
                   for i in range(len(l) + 1):
                       result.append(l[:i] + [head] + l[i:])
               return result
       return sorted(go(lst)) # 最后排序，减少时间开销
   ```

   上面的代码有一定的优化空间，例如把`range(len(l) + 1)`提到前面去，但不会在时间复杂度上有太大的变化。

   如果用回溯法，代码会更清晰也更简单，但这需要一定的技巧。当然，作为一种非常基础的算法，回溯是建议认真学习的：

   ```python
   def func3(lst):
           def backtrack(first=0):
               # 所有数都填完了
               if first == n:  
                   result.append(nums[:])
               for i in range(first, n):
                   # 动态维护数组
                   nums[first], nums[i] = nums[i], nums[first]
                   # 继续递归填下一个数
                   backtrack(first + 1)
                   # 撤销操作
                   nums[first], nums[i] = nums[i], nums[first]
           
           n = len(nums)
           result = []
           backtrack()
           return sorted(result)
   ```

   上面这个解法来自LeetCode题库第46题的官方题解。如果你对这种解法感到很陌生，可以直接去LeetCode看题解，并认真学习一下回溯。此外全排列这道题过于经典，因此应当全网都能找到很多教程，这里就不赘述了。

   此外Python中也确实存在函数可以直接进行全排列。但这种解法过于简单，所以2021年这么做题的人**全部得了零分**。下面给出这种解法，但**这个解法在考试里是没有分的**。

   ```python
   def func3(lst):
       from itertools import permutations
       return sorted(map(list, permutations(lst)))
   ```

   itertools模块中的函数全都是用C语言实现的，因此速度比较快。官方文档也提供了一种使用Python的实现，这个实现返回一个迭代器，感兴趣可以看一下。其中参数r可以指定生成序列的长度，否则默认生成长度为iterable长度的排列。

   ```python
   def permutations(iterable, r=None):
       # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
       # permutations(range(3)) --> 012 021 102 120 201 210
       pool = tuple(iterable)
       n = len(pool)
       r = n if r is None else r
       if r > n:
           return
       indices = list(range(n))
       cycles = list(range(n, n-r, -1))
       yield tuple(pool[i] for i in indices[:r])
       while n:
           for i in reversed(range(r)):
               cycles[i] -= 1
               if cycles[i] == 0:
                   indices[i:] = indices[i+1:] + indices[i:i+1]
                   cycles[i] = n - i
               else:
                   j = cycles[i]
                   indices[i], indices[-j] = indices[-j], indices[i]
                   yield tuple(pool[i] for i in indices[:r])
                   break
           else:
               return
   ```

   官方文档中还提供了另一种使用product的实现，感兴趣可以阅读[https://docs.python.org/zh-cn/3/library/itertools.html?highlight=permutations#itertools.permutations](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=permutations#itertools.permutations)

   ---

4. 现有一个全部是英文字母的字符串string，string中包含了若干个单词，单词和单词之间以一个空格分开，string的最前面和最后面没有空格。请编写程序对这些单词排序，返回排序单词组成的字符串。返回结果时单词和单词之间用一个空格分开，最前面和最后面没有空格。 

   **排序规则如下：**

   - 首先，按照单词长度从大到小排序；
   - 其次，单词长度相等时按照字典序从小到大排序（不区分大小写）；
   - 最后，如果两个单词不区分大小写后相同，则按照ASCII码从小到大排序

   | **相关说明** |                                                |
   | ------------ | ---------------------------------------------- |
   | 输入条件     | 用空格分开每个单词的字符串（至少包含两个单词） |
   | 输出要求     | 用空格分开每个单词的字符串                     |
   | 其它要求     | 将代码写入函数func4                            |

   ---

   测试用例：

   | **输入**           | **输出**           |
   | ------------------ | ------------------ |
   | "long long ago"    | "long long ago"    |
   | "hello Hello hell" | "Hello hello hell" |
   | "a A an"           | "an A a"           |

   ---

   <b>解：</b>

   ---

5. 篮球三分球团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。现给定所有队员的比赛成绩，请你编写程序找出冠军队。

   输入是一个列表lst，它的每个元素是一个包含三个元素的列表，三个元素都是整型，分别代表队伍编号、队员编号和成绩。

   - 其中队伍编号为1到1000的正整数；
   - 队员编号为1到10的正整数；
   - 成绩为0到100的整数；
   - 题目输入保证冠军队是唯一的。

   | **相关说明** |                                                              |
   | ------------ | ------------------------------------------------------------ |
   | 输入条件     | lst是一个非空二维列表                                        |
   | 输出要求     | 以元组的形式返回结果，元组的第一个元素是队伍编号，第 二个元素是成绩 |
   | 其它要求     | 将代码写入函数func5                                          |

   ---

   **测试用例：**

   | **输入**                                        | **输出**   |
   | ----------------------------------------------- | ---------- |
   | [[2,1,5],[3,1,3],[4,1,3],[2,2,15],[8,1,18]] | (2,20) |
   | [[2,1,5]]                                   | (2,5)  |
   | [[2,1,5],[3,2,7]]                           | (3,7)  |

   ---

6. 有一个机器人爬楼梯，它每步可以爬1阶，也可以爬2阶。如果合计有1阶，那么该机器人只有1种走法；如果合计有2阶，机器人可以走2次1阶，也可以1次走2级，因此有2种走法。编写程序计算$$n$$米机器人有多少种走法。

   | **相关说明** |                                    |
   | ------------ | ---------------------------------- |
   | 输入条件     | $$n$$一定是正整数                    |
   | 输出要求     | 输出一个整数，代表机器人的走法数量 |
   | 其它要求     | 将代码写入函数func6                |

   ---

   测试用例：

   | **输入** | **输出** |
   | -------- | -------- |
   | 1        | 1        |
   | 2        | 2        |
   | 4        | 5        |

   ---

7. 给定一个由元组构成的列表lst，其中每个元组由2个0至99之间的整数元素构成。设有两个元组$$t_1$$和$$t_2$$，如果$$t_1$$中的元素都不比$$t_2$$中对应（同一位置）的元素大，且$$t_1$$中至少存在一个元素比$$t_2$$中对应元素小，则称$$t_1$$支配$$t_2$$。保留lst中所有不被任何元组支配的元组，并将lst按元组第1个元素从小到大的顺序排列。返回排序后的列表lst。

   | **相关说明** |                                 |
   | ------------ | ------------------------------- |
   | 输入条件     | 列表lst一定是满足题意的合法输入 |
   | 输出要求     | 返回列表lst                     |
   | 其它要求     | 将代码写入函数func7             |

   ---

   测试用例：

   | **输入**                                                     | **输出**            |
   | ------------------------------------------------------------ | ------------------- |
   | [(4, 2), (88, 21), (25, 27), (40, 72), (17, 33),  (79, 14), (67, 66), (7, 18)] | [(4, 2)]            |
   | [(5, 94), (68, 73), (77, 73), (21, 14), (30, 81),  (43, 60), (73, 68), (84, 61)] | [(5, 94), (21, 14)] |
   | [(42, 11), (49, 46), (89, 33), (89, 96), (13, 1),  (89, 11), (45, 39), (23, 5)] | [(13, 1)]           |

   ---

8. 已知一个元素都是整数的等差数列缺失了一个值，求出这个缺失值。

   | **相关说明** |                                                              |
   | ------------ | ------------------------------------------------------------ |
   | 输入条件     | 参数lst是一个未排序整数列表。缺失值一定不在数列的两端。      |
   | 输出要求     | 返回一个缺失的值，可使得lst构成等差数列。如lst长度小于4，则返回None。 |
   | 其它要求     | 将代码写入函数func8                                          |

   ---

   测试用例：

   | **输入**                     | **输出** |
   | ---------------------------- | -------- |
   | [1, 2, 3, 4, 5, 8, 7, 9, 10] | 6        |
   | [3, 4, 1, 2, 5, 6, 7, 9, 10] | 8        |
   | [2, 4, 6, 8, 12]             | 10       |
